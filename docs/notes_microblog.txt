===================================================


See the blog "The Flask Mega-Tutorial  [December 5 2017]" at
https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world

===================================================

A kind of REAME.first file
===================================================
TO DO: app sources download
$ git config --global http.proxy http://proxy.mycompany:80
$ git clone https://github.com/daniel-julio-iglesias/microblog

PyCharm action: [right click] Git --> Commit File ... --> Commit
PyCharm action: [right click] Git --> Repository --> Push ... --> Push


===================================================
TO DO: install these packages after app sources download


(venv) $ pip install flask
(venv) $ pip install --proxy http://user:pass@proxyAddress:proxyPort flask

(venv) $ pip install flask-wtf
(venv) $ pip install flask-sqlalchemy
(venv) $ pip install flask-migrate
(venv) $ pip install flask-login
===================================================

TO DO: apply the next db steps after downloading your app sources

Linux
(venv) $ export FLASK_APP=microblog.py
MS
(venv) $ set FLASK_APP=microblog.py

(venv) $ flask db upgrade

===================================================
===================================================
===================================================

$ mkdir microblog
$ cd microblog

$ python3 -m venv venv

$ virtualenv venv

Linux
$ source venv/bin/activate
(venv) $ _

MS
$ venv\Scripts\activate
(venv) $ _

===================================================

(venv) $ pip install flask


Linux
(venv) $ export FLASK_APP=microblog.py
MS
(venv) $ set FLASK_APP=microblog.py

(venv) $ flask run


URL: http://localhost:5000/
URL: http://localhost:5000/index

===================================================

(venv) $ pip install flask-wtf
(venv) $ pip install flask-sqlalchemy
(venv) $ pip install flask-migrate




>>> from app.models import User
>>> u = User(username='susan', email='susan@example.com')
>>> u


===================================================
===================================================

Linux
(venv) $ export FLASK_APP=microblog.py
MS
(venv) $ set FLASK_APP=microblog.py


(venv) $ flask db init
(venv) $ flask db migrate -m "users table"
(venv) $ flask db upgrade
(venv) $ flask db migrate -m "posts table"
(venv) $ flask db upgrade
===================================================
===================================================

>>> from app import db
>>> from app.models import User, Post

>>> u = User(username='john', email='john@example.com')
>>> db.session.add(u)
>>> db.session.commit()

>>> u = User(username='susan', email='susan@example.com')
>>> db.session.add(u)
>>> db.session.commit()

db.session.rollback()


>>> users = User.query.all()
>>> users
[<User john>, <User susan>]
>>> for u in users:
...     print(u.id, u.username)
...
1 john
2 susan

>>> u = User.query.get(1)
>>> u
<User john>

>>> u = User.query.get(1)
>>> p = Post(body='my first post!', author=u)
>>> db.session.add(p)
>>> db.session.commit()



===================================================

>>> # get all posts written by a user
>>> u = User.query.get(1)
>>> u
<User john>
>>> posts = u.posts.all()
>>> posts
[<Post my first post!>]

>>> # same, but with a user that has no posts
>>> u = User.query.get(2)
>>> u
<User susan>
>>> u.posts.all()
[]

>>> # print post author and body for all posts
>>> posts = Post.query.all()
>>> for p in posts:
...     print(p.id, p.author.username, p.body)
...
1 john my first post!

# get all users in reverse alphabetical order
>>> User.query.order_by(User.username.desc()).all()
[<User susan>, <User john>]

===================================================

>>> users = User.query.all()
>>> for u in users:
...     db.session.delete(u)
...
>>> posts = Post.query.all()
>>> for p in posts:
...     db.session.delete(p)
...
>>> db.session.commit()

===================================================


(venv) $ python
>>> app
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'app' is not defined
>>>

(venv) $ flask shell
>>> app
<Flask 'app'>

===================================================

Linux
(venv) $ export FLASK_APP=microblog.py
MS
(venv) $ set FLASK_APP=microblog.py


(venv) $ flask shell
>>> db
<SQLAlchemy engine=sqlite:////Users/migu7781/Documents/dev/flask/microblog2/app.db>
>>> User
<class 'app.models.User'>
>>> Post
<class 'app.models.Post'>




>>> u = User(username='susan', email='susan@example.com')
>>> u.set_password('mypassword')
>>> u.check_password('anotherpassword')
False
>>> u.check_password('mypassword')
True


===================================================


(venv) $ pip install flask-login

===================================================
Linux
(venv) $ export FLASK_APP=microblog.py
MS
(venv) $ set FLASK_APP=microblog.py

(venv) $ flask shell

>>> u = User(username='susan', email='susan@example.com')
>>> u.set_password('cat')
>>> db.session.add(u)
>>> db.session.commit()
-----------------------
>>> u = User(username='daniel', email='daniel@example.com')
>>> u.set_password('dog')
>>> db.session.add(u)
>>> db.session.commit()

(venv) $ flask run

(venv) $ flask run -h 0.0.0.0
===================================================
===================================================

Finished at The Flask Mega-Tutorial Part V: User Logins  [January 2 2018]
https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-v-user-logins

===================================================

To continue with
The Flask Mega-Tutorial Part VI: Profile Page and Avatars
https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vi-profile-page-and-avatars

===================================================
===================================================

Linux
(venv) $ export FLASK_APP=microblog.py
MS
(venv) $ set FLASK_APP=microblog.py

(venv) $ flask shell

>>> User.query.all()
>>> u = User(username='john', email='john@example.com')
>>> u.set_password('bug')
>>> db.session.add(u)
>>> db.session.commit()

(venv) $ flask run

http://localhost:5000/user/john


===================================================


The Gravatar service is very simple to use. To request an image for a given user,
a URL with the format https://www.gravatar.com/avatar/<hash>, where <hash> is the MD5 hash
of the user's email address.
Below you can see how to obtain the Gravatar URL for a user with email john@example.com:

>>> from hashlib import md5
>>> 'https://www.gravatar.com/avatar/' + md5(b'john@example.com').hexdigest()
'https://www.gravatar.com/avatar/d4c74594d841139328695756648b6bd6'
'https://www.gravatar.com/avatar/d4c74594d841139328695756648b6bd6'


>>> 'https://www.gravatar.com/avatar/' + md5(b'myemail@example.com').hexdigest()
'https://www.gravatar.com/avatar/f69e4c7018d22371bb6dac594d928992'
https://www.gravatar.com/avatar/f69e4c7018d22371bb6dac594d928992?s=128

===================================================

Linux
(venv) $ export FLASK_APP=microblog.py
MS
(venv) $ set FLASK_APP=microblog.py

(venv) $ flask shell

>>> me = User.query.filter_by(username='daniel').first()
>>> db.session.delete(me)
>>> db.session.commit()
>>> me = User(username='daniel', email='myemail@example.com')
>>> me.set_password('dog')
>>> db.session.add(me)
>>> db.session.commit()
>>> User.query.all()

===================================================
===================================================

To continue with
The Flask Mega-Tutorial Part VI: Profile Page and Avatars
https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vi-profile-page-and-avatars


Using Jinja2 Sub-Templates

===================================================

(venv) $ flask db migrate -m "new fields in user model"
(venv) $ flask db upgrade

===================================================

Linux
(venv) $ export FLASK_APP=microblog.py
MS
(venv) $ set FLASK_APP=microblog.py

(venv) $ flask shell
(venv) $ flask run

===================================================

Finished with
The Flask Mega-Tutorial Part VI: Profile Page and Avatars

===================================================
===================================================

To continue with
The Flask Mega-Tutorial Part VII: Error Handling
https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-vii-error-handling

===================================================

Linux
(venv) $ export FLASK_APP=microblog.py
MS
(venv) $ set FLASK_APP=microblog.py

(venv) $ flask shell
(venv) $ flask run

===================================================
>>> u = User(username='susan', email='susan@example.com')
>>> u.set_password('cat')

>>> u = User(username='daniel', email='daniel@example.com')
>>> u.set_password('dog')

===================================================
Linux
(venv) $ export FLASK_DEBUG=1
MS
(venv) $ set FLASK_DEBUG=1

===================================================

The debugger caught an exception in your WSGI application. You can now look at the
traceback which led to the error.

To switch between the interactive traceback and the plaintext one, you can click on
the "Traceback" headline.
From the text traceback you can also create a paste of it. For code execution
mouse-over the frame you want to debug
and click on the console icon on the right side.

You can execute arbitrary Python code in the stack frames and there are some
extra helpers available for introspection:

    dump() shows all variables in the frame
    dump(obj) dumps all that's known about the object

===================================================

Linux
(venv) $ export FLASK_DEBUG=0
MS
(venv) $ set FLASK_DEBUG=0

===================================================

The easiest one is to use the SMTP debugging server from Python.
This is a fake email server that accepts emails, but instead of sending them,
it prints them to the console. To run this server, open a second terminal
session and run the following command on it:


(venv) $ python -m smtpd -n -c DebuggingServer localhost:8025

-------------

Leave the debugging SMTP server running and go back to your first terminal and set

Linux
(venv) $ export FLASK_DEBUG=0
MS
(venv) $ set FLASK_DEBUG=0


Linux
(venv) $ export MAIL_SERVER=localhost
MS
(venv) $ set MAIL_SERVER=localhost


Linux
(venv) $ export MAIL_PORT=8025
MS
(venv) $ set MAIL_PORT=8025


-------------

---------- MESSAGE FOLLOWS ----------
b'From: no-reply@localhost'
b'To: my-email@example.com'
b'Subject: Microblog Failure'
b'Date: Sun, 19 Aug 2018 18:39:19 +0300'
b'Content-Type: text/plain; charset="utf-8"'
b'Content-Transfer-Encoding: 7bit'
b'MIME-Version: 1.0'
b'X-Peer: ::1'
b''
b'Exception on /edit_profile [POST]'
b'Traceback (most recent call last):'
(...)
b'sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: user.username [SQL: \'UPDATE user SET username=?, about_me=? WHERE user.id = ?\']
 [parameters: (\'susan\', "This is Susan\'s profile", 4)] (Background on this error at: http://sqlalche.me/e/gkpj)'
===================================================

A second testing approach for this feature is to configure
a real email server. Below is the configuration to use your Gmail account's email server:

export MAIL_SERVER=smtp.googlemail.com
export MAIL_PORT=587
export MAIL_USE_TLS=1
export MAIL_USERNAME=<your-gmail-username>
export MAIL_PASSWORD=<your-gmail-password>

If you are using Microsoft Windows, remember to use
set instead of export in each of the statements above.

===================================================
The security features in your Gmail account may prevent
the application from sending emails through it unless
you explicitly allow "less secure apps" access to your
Gmail account. You can read about this here, and
if you are concerned about the security of your account,
you can create a secondary account that you configure
just for testing emails, or you can enable less secure
apps only temporarily to run this test and then revert
back to the default.

https://support.google.com/accounts/answer/6010255?hl=en


Let less secure apps access your account

If an app or device doesn’t meet our security standards,
Google will block anyone who tries to sign in from that app or device.
Because these apps and devices are easier to break into, blocking
them helps keep your account safe.

Some examples of apps that do not support the latest security standards include:

The Mail app on your iPhone or iPad with version 6 or below
The Mail app on your Windows phone preceding the 8.1 release
Some Desktop mail clients like Microsoft Outlook and Mozilla Thunderbird
Change account access for less secure apps
To help keep Google Accounts through work, school, or other groups more secure,
we block some less secure apps from using them. If you have this kind of account,
you’ll see a "Password incorrect" error when trying to sign in. If so,
you have two options:

Option 1: Install a more secure app that uses stronger security measures.
All Google products, like Gmail, use the latest security measures.
Option 2: Change your settings to allow less secure apps into your account.
We don't recommend this option because it can make it easier for someone
to break into your account. If you want to allow access anyway, follow these steps:
Go to the Less secure apps section of your Google Account.
Turn on Allow less secure apps. If you don't see this setting,
your administrator might have turned off less secure app account access.
If you still can't sign in to your account, learn more about the
"password incorrect" error.


===================================================

Finished
The Flask Mega-Tutorial Part VII: Error Handling

===================================================
===================================================

Continue with
The Flask Mega-Tutorial Part VIII: Followers
https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-viii-followers


===================================================



===================================================






===================================================




===================================================




===================================================
